# SpartaB06_RawMeat


# 프레임워크 
## 개요
- 현재 프로젝트의 전반적인 게임 프레임워크에 대한 설명입니다.

## 프레임워크 설계의 이유
- 팀원들과의 협업을 위해 전체적인 구조를 지정하고 들어가지 않는다면 산발적인 코드가 될 것을 예상 하였습니다.
- 그래서 팀원들 각 각이 특정 부분에 집중할 수 있도록 구조를 짜, 적은 소통으로도 원활한 코딩이 가능하도록 하기 위함이었습니다.
- 실제로 설계구조가 설정되고 같은 구조 속에서 프로그램을 짜게되어 같은 생각/논리를 생각할 수 있어서 보다 원활한 코딩이 가능하였습니다.
- 특히 각 부분별로 나누기 편하게 구조화되어서 코딩 간 간섭이 적은 환경이 유지될 수 있었습니다.
- 이로 인해 동시코딩이 가능하여 실력에 상관없이 빠른 구현이 가능했습니다.
  

### 구조도
![이미지](Image/간략한%20플로우%20차트.png)

- 게임의 흐름은 GameCore에 구현되어있으며 다음과 같은 흐름으로 작동하게됩니다.
- 행동부분은 Scene부분으로 화면의 출력과 화면에 맞는 행동입력, 행동을 수행하게됩니다.
- 행동에 있어 여러 예외상황을 위해, 입력 무시 기능이 있습니다.
- 입력 무시시 원하는 행동(Scene)으로의 이동을 강제하여 Scene전환을 수행합니다.

<br>
<br>

### 클래스 다이어그램
![이미지](Image/간략한%20클래스%20다이어그램.png)

GameCore의 흐름에 따라 다음과 같은 클래스들을 사용하게 됩니다.
<br>
<br>
<br>

### 클래스 설명
#### DataManager : 
    - 게임 실행 중 기본데이터/유저데이터 등의 모든 데이터를 보유하고 있는 클래스
    - 현재 플레이어, 싸움중인 몬스터, 다음 실행해야할 행동, 인벤토리, 입력정보 등을 보유하고 있습니다
    - 상점리스트, 던전 층별 몬스터 종류, 몬스터의 능력치, 직업 등 <br> 게임 전반에 쓰이는 데이터 풀을 보유하고 있습니다.
[코드 참조](../../BasicTeamProject/BasicTeamProject/src/Data/DataManager.cs#L0-30)

#### DataContainer :
    - 외부 텍스트 데이터를 DataReader의 기능(상속)으로 읽어온 후 각 데이터 클래스에 맞게 가공합니다.
    - 오브젝트 풀을 이용하여 기본 데이터들을 저장하고 있습니다.

#### DataReader :
    - "|" 로 구분된 텍스트 데이터를 읽어 string[]으로 분할하여 반환해주는 클래스입니다.
    - 구체적인 데이터의 가공/설정은 DataContainer로 수행하고 있습니다.

#### SceneManager : 
    - 현재 프로그램상의 모든 Scene 파생클래스를 불러와 ObjectPool을 이용 Scene을 보관하는 클래스
    - 클래스 이름을 통해 Scene 요청을 하면 Scene 데이터를 반환해준다.
    - 리플렉션 기능 중 상속된 클래스를 가져오는 기능을 활용,<br> Scene 파생클래스의 추가에도 별도 작업없이 SceneManager에 포함 가능


#### Scene :
    - 모든 Scene의 기본이 되는 추상 클래스
    - 데코레이트 패턴으로 구성되어있음
    - Execute를 이용 상속된 클래스의 내용을 실행하게 됨

#### ConcreteScene :
    - 실제적인 Scene을 구현하는 부분
    - DataManager를 이용 현재 플레이어 데이터, 던전의 데이터 등을 참고하여 Scene의 모양을 잡음.
    - SceneManager의 리플렉션 기능에 의해 자동으로 SceneManager에 등록이 되며,
    - 매 입력 시 다음 Scene에 대한 정보를 남겨서 GameCore에 반환하면
    - GameCore에서는 다음 Scene에 대한 정보를 토대로 다음화면을 시현해줌


<br>


## 구현 소감 :
### 예외상황에 대한 대처 부족
    - 현 프레임워크 상황에서는  입력(GameCore) -> 출력 (Scene)-> 다시 입력(GameCore)의 방향으로 흐름이 흐르는데
    - 숫자 입력 외에 다른 입력에 대한 예외상황을 보유 하지 못했습니다.
    - 따라서 이를 극복하기 위해서 InputMemory라는 이전 입력을 기억하는 클래스를 제작하였습니다.
    - 추가적인 InputMemory에 입력 무시기능을 탑재하여, 예외의 입력에 대해 Scene에서 처리하도록 수정하였습니다.

    - 이 과정에서 기존 프레임워크의 흐름을 무시하는 기능이 추가되, 예상하지 못한 오류들을 만날 것을 예상하였으나 
    - 다행이 그런일은 일어나지 않았습니다.
 - ### 개선 방안 
   - 구조를 설계할 때 Scene 내에서 입력을 처리하도록 수정하고, 입력에 따라 외부에서 어떤 씬으로 이동할 지의 정보를 전달하는 방식으로 수정했다면 보다 좋은 프레임워크가 되었을 것으로 생각됩니다.
   - 입력 기능이 Scene 외부에 있음으로 다양한 입력을 대처하기 어려웠던 점, 흐름상 이상해졌던 부분이 존재 했었습니다.
   - 이 부분 개선하기 위해 InputMemory에 입력을 한번 무시해 줄 수 있는 추가, Scene 내부에서 입력처리를 할 수 있도록 수정하면서 보다 다양하게 기능을 구현할 수 있었습니다.


- ### 앞으로의 구현
    - 이번 구현을 통해서 정해진 형식도 좋지만, 다양한 상황에 대한 대처를 할 수 있는 설계를 해야한다는 것을 알 수 있었습니다. 제 설계에서의 아쉬웠던 점은 Scene을 출력 하나만을 고려된 클래스였던 것이, 입력을 받아야 될 상황이 발생하는 것을 간과했고, 그러다 보니 전체적인 Core부분이 변경된다는 점이었습니다. 그로 인해 파생되는 사이드 이펙트들로 고생할 수도 있다는 것을 느꼈습니다. 
    - 기능들을 분리하는 것도 좋지만, 통합하여 사용하는 부분도 필요하다는 것을 알게되어, 앞으로는 설계시에 기능의 분리 전 후의 장단점을 따져서 프레임워크를 구현할 것입니다.
  